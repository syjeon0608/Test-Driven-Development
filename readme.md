### **1. 동시성 제어의 필요성**

- 동시성 문제가 발생할 경우, 두 개 이상의 프로세스가 동일한 데이터를 동시에 수정하려고 할 때 경쟁 조건이 발생할 수 있습니다. 이 경우, 이전 작업이 완료되지 않은 상태에서 포인트를 사용하려고 하면 잔액 업데이트가 정확하지 않거나, 올바른 비즈니스 로직을 따르지 않을 수 있습니다. 이를 방지하기 위해 적절한 동시성 제어가 필요합니다.
- 또 여러 사용자가 동시에 포인트를 충전하거나 사용할 경우, 무한 쓰레드가 발생해 대기시간이 길어질  수 있습니다. 이러한 문제를 해결하기 위해 비동기 처리도 필요합니다.

### **2. 동시성 제어 방법**

**2.1. ReentrantLock**

**ReentrantLock**은 자원에 대한 동시 접근을 제어하기 위해 사용되는 Lock 클래스의 일종으로, 스레드 안전성을 확보하는 데 중요한 역할을 합니다. 이 Lock은 다음과 같은 특징을 가지고 있습니다

• **재진입성 (Reentrancy)**: 동일한 스레드가 이미 획득한 Lock을 다시 획득할 수 있도록 하여, Deadlock의 위험을 줄입니다. 예를 들어, A 스레드가 Lock을 획득한 상태에서 동일한 스레드가 Lock을 다시 요청하더라도, Lock을 획득할 수 있습니다. 이는 복잡한 데이터 구조를 다루는 상황에서 유용합니다.

• **Lock 관리**: ConcurrentHashMap을 통해 사용자 ID에 따라 Lock 객체를 관리하여, 각 사용자에 대한 동시 접근을 효과적으로 제어합니다. 이를 통해 서로 다른 스레드가 동일한 사용자 데이터에 접근할 때 Lock이 작동하여 충돌을 방지하고, 데이터의 일관성을 유지할 수 있습니다.

• **Lock의 사용**: 포인트 충전 및 사용 요청 처리 시, Lock을 획득한 후 작업을 수행하고, 최종적으로 Lock을 해제합니다. 이 과정은 try-finally 블록을 사용하여 예외가 발생하더라도 Lock이 항상 해제되도록 보장합니다.

**2.2. CompletableFuture**

포인트 충전 및 사용 요청은 **CompletableFuture**를 사용하여 비동기로 처리하였습니다. 비동기 처리는 다음과 같은 이점을 제공합니다

• **응답성 향상**: 사용자 요청이 들어올 때, 해당 요청이 완료될 때까지 대기하지 않고 다른 작업을 병렬적으로 수행할 수 있습니다. 이를 통해 사용자 경험을 개선하고, 시스템의 전반적인 응답 속도를 높일 수 있습니다.

• **비동기 작업의 관리**: **CompletableFuture**는 비동기 작업을 쉽게 관리할 수 있도록 도와줍니다. 여러 비동기 작업을 수행하고, 모든 작업이 완료되기를 기다리는 기능을 제공하여 코드의 가독성을 높입니다. 예를 들어, CompletableFuture.allOf() 메서드를 사용하여 여러 비동기 작업이 모두 완료될 때까지 기다릴 수 있습니다.

• **비동기 처리를 통한 성능 개선**: 비동기 처리 방식은 여러 요청을 동시에 처리할 수 있는 가능성을 제공하여 시스템의 성능을 향상시킵니다. 특히, 포인트 충전이나 사용 요청과 같은 반복적인 작업에서 성능을 극대화할 수 있습니다.

ReentrantLock과 CompletableFuture의 조합은 동시성 제어에 있어 강력한 시너지를 발휘합니다. 이 두 기술을 함께 사용한 이유는 다음과 같습니다

• **안전성과 효율성**: ReentrantLock을 통해 동시 접근을 안전하게 제어하면서, CompletableFuture를 통해 비동기 처리를 구현함으로써 시스템의 효율성을 극대화할 수 있었습니다. Lock이 필요한 부분에서는 데이터 일관성을 보장하고, 비동기 처리로 사용자의 요청에 빠르게 응답할 수 있는 구조를 만들었습니다.

• **복잡한 작업 처리**: 포인트 충전 및 사용과 같은 복잡한 작업에서는 여러 스레드가 동시에 자원에 접근해야 하므로, Lock을 사용하여 충돌을 방지하는 것이 필수적입니다. 그러나 비동기적으로 처리함으로써 사용자 경험을 해치지 않고, 모든 요청을 효과적으로 처리할 수 있었습니다.

• **유연한 응답성**: 비동기 처리는 사용자 요청이 완료될 때까지 대기하지 않기 때문에, 시스템은 다양한 요청을 동시에 처리할 수 있는 유연성을 가집니다.

이러한 이유로 ReentrantLock과 CompletableFuture를 조합하여 동시성 제어를 구현함으로써, 데이터의 일관성을 유지하면서도 효율적인 사용자 경험을 제공할 수 있습니다.

### **3. 테스트코드 작성**

동시성 제어의 유효성을 검증하기 위해 통합 테스트 케이스를 작성하였습니다.

3.1 동일유저에 대한 동시성 제어 테스트 케이스

- 동시에 동일한 유저가 여러 개의 포인트 충전 요청을 보낼 때 병렬적으로 처리되어야 한다.
- 동시에 동일한 유저가 여러 개의 포인트 사용 요청을 보낼 때 병렬적으로 처리되어야 한다.
- 동시에 동일한 유저에게 여러 개의 포인트 충전 및 사용 요청할 때 모든 작업이 정상적으로 처리되어야 한다.

3.2 서로 다른 유저 간 작업 비동기 처리 테스트 케이스

- 동시에 서로 다른 유저가 각각 포인트 충전 요청을 보낼 때 병렬로 처리되어야 한다.
- 동시에 서로 다른 유저가 각각 동시에 포인트 사용 요청을 보낼 때 병렬로 처리되어야 한다.
- 동시에 A, B, C 유저가 각각 포인트 충전 및 사용을 요청할 때 모든 작업이 정상적으로 처리되어야 한다.

- 비동기 상황을 가정하기 위해 **`CompletableFuture`**를 활용하였습니다. 각 포인트 사용 요청은 다음과 같이 비동기적으로 처리됩니다.

```java
CompletableFuture<UserPoint> future1 = pointService.usePoints(1L, 10L);
CompletableFuture<UserPoint> future2 = pointService.usePoints(1L, 30L);
CompletableFuture<UserPoint> future3 = pointService.usePoints(1L, 20L);
```

- `CompletableFuture.allOf().join()`를 사용하여 비동기 처리가 완료될 때까지 기다렸습니다.

```java
CompletableFuture.allOf(future1, future2, future3).join();
```

이후, 최종 포인트 값을 검증하여 예상한 값과 비교합니다.

```java
UserPoint finalUserPoint = userPointRepository.selectById(1L).orElseThrow();
assertEquals(40L, finalUserPoint.point());  // 최종 포인트 검증
```

이와 같은 방식으로 비동기 상황을 가정한 후, 예상한 값과 비동기 처리가 완료된 최종값을 비교하여 동시성 제어의 유효성을 검증하였습니다.

### 4. 마무리

동시성을 제어할 수 있는 방법은 매우 다양합니다. 따라서 애플리케이션의 요구 사항에 맞춰 적절한 동시성 제어 방식을 선택하고 이를 신중하게 조합하는 것이 중요하다고 생각합니다. 또한, 동시성 제어 통합 테스트를 작성하는 과정에서 우리가 어떤 상황을 예상하고 통제해야 하는지를 이해하게 되었습니다.